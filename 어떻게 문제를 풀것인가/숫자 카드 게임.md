## 어떻게 문제를 풀 것인가?
### 1. 문제에 대한 이해
#### 우리가 풀어야 할 문제는 무엇인가?
    n x m 형태의 카드가있는데 각 행마다 가장 작은수를 찾은뒤에 그 수 중에서 가장 큰 수를 찾는것
#### 주어진 자료는 무엇인가?
    [행, 열] , [숫자들이 담긴 배열]
#### 조건은 무엇인가?
    첫째줄은 n(행) m(열) 의 갯수를 기준으로 하여 각각 자연수로 주어진다. n은 1이상이고 m은 100이하이다
    둘째줄을 n(행)개 줄에 걸쳐 카드가 적힌 숫자(1이상 10,000 이하 자연수) 가 주어진다
#### 우리가 문제를 풀기 위해 주어진 자료가 충분한가?
#### 숨겨진 조건이나 자료가 있는가? 그렇다면 그 것을 다른 방법으로 해석해보라.

### 2. 계획
#### 전에 비슷한 문제를 알고 있는가?
    모릅니다
#### 이 문제를 푸는데 있어서 유용하게 쓸 수 있는 지식은 무엇인가?
    slice (배열 자르기), push(배열 추가), sort( 정렬 )
#### 비슷한 문제를 풀어본 적이 있다면 그 것을 활용할 수 있는가?
#### 만약 문제를 풀 수 없다면 문제를 더 단순하게 하기 위해서 주어진 조건을 버려보아라
#### 주어진 자료로부터 유용한 것을 이끌어 낼 수 있는가?
#### 자료는 모두 사용했는가?
#### 조건을 모두 사용했는가?
#### 문제에 포함된 핵심적인 개념은 모두 고려했는가?

### 3. 실행
#### 풀이 계획을 실행하고, 각 단계가 올바른지 점검하라.
[3,3],[3,1,2,4,1,4,2,2,2] 이라는 가정

1. [3,1,2,4,1,4,2,2,2] 를 3(행)개씩 3(열)묶음으로 나눠준다 => [ [3,1,2],[4,1,4],[2,2,2] ]
    1. 3(열)만큼 반복문 생성
    2. 배열의 인덱스 (0~2 , 2~4 , 4~6) 를 담아서 새로운 배열에다가 Push
2. [ [3,1,2],[4,1,4],[2,2,2] ] 배열안에 배열중에 제일 작은 숫자를 찾아서 배열을 만든다 => [1,1,2]
    1. map을 사용해 오름차순으로 정렬한뒤 배열의 0번째 index만 모아주었다
3. [1,1,2] 중에 제일 큰 값을 찾는다 => 2
    1. sort를 사용해 오름차순으로 정렬
4. return 2 를 한다
    1. 오름차순된 배열의 0번째 index를 return 해준다

### 4. 반성
#### 문제를 다른 방식으로 해결할 수 있는가?
#### 결과나 방법을 어떤 다른 문제에 활용할 수 있는가?
#### 어떻게 하면 더 효율적으로 문제를 해결할 수 있는가?
#### 어떻게 하면 더 효과적으로 문제를 해결할 수 있는가?